# Лабораторная работа № 2
# Основные структуры данных. Анализ и применение

**Дата:** 28.11.2025
**Семестр:** 3 курс 5 семестр
**Группа:** ПИЖ-б-о-23-2-2
**Дисциплина:** Анализ сложности алгоритмов
**Студент:** Зволибовская Екатерина Валерьевна

## Характеристики ПК для тестирования
- Процессор: 11th Gen Intel(R) Core(TM) i5-11400F CPU @ 2.60 GHz
- GPU: NVIDEA GeForce RTX 4060
- Оперативная память: 16 GB
- ОС: Windows 10
- Python: 3.11 (64-bit)

## Цель работы
Изучить понятие и особенности базовых абстрактных типов данных (стек, очередь, дек,
связный список) и их реализаций в Python. Научиться выбирать оптимальную структуру данных для
решения конкретной задачи, основываясь на анализе теоретической и практической сложности
операций. Получить навыки измерения производительности и применения структур данных для
решения практических задач.

## Практическая часть

### Выполненные задачи
- [x] Реализация связного списка (LinkedList) с методами вставки, удаления и обхода
- [x] Сравнительный анализ производительности операций для разных структур данных
- [x] Реализация алгоритмов проверки сбалансированности скобок, симуляции очереди и проверки палиндромов
- [x] Визуализация результатов анализа производительности

### Ключевые фрагменты кода
```python
class Node:

    def __init__(self, data):
        self.data = data
        self.next = None

class LinkedList:
    def insert_at_start(self, data):  # O(1)
        new_node = Node(data)
        if self.head is None:
            self.head = new_node
            self.tail = new_node
        else:
            new_node.next = self.head
            self.head = new_node
    
    def delete_from_start(self):  # O(1)
        if self.head is None:
            return None
        data = self.head.data
        self.head = self.head.next
        if self.head is None:
            self.tail = None
        return data
```

## Результаты выполнения

### Пример работы программы
```bash
Лабораторная работа 2: Анализ структур данных
==================================================
Запуск анализа производительности
Сравнение производительности вставки в начало:
Кол-во элементов        list.insert(0)  LinkedList.insert_at_start
100                     0.000254                0.000667
500                     0.000448                0.001318
1000                    0.000677                0.002605
2000                    0.002120                0.005011
5000                    0.004041                0.017092

Сравнение производительности операций очереди:
Кол-во операций         list.pop(0)     deque.popleft()
100                     0.000074                0.000056
500                     0.000171                0.000112
1000                    0.000311                0.000204
2000                    0.000588                0.000391
5000                    0.001726                0.001557
```


## Выводы

В ходе лабораторной работы проведён сравнительный анализ производительности структур данных и реализован собственный связный список.

Основные результаты исследования:

На практике list.insert(0) оказался быстрее LinkedList.insert_at_start, несмотря на теоретическую сложность O(n) против O(1). Это связано с тем, что встроенные списки Python реализованы на C и сильно оптимизированы, тогда как пользовательский связный список создаёт накладные расходы на создание объектов и работу с атрибутами в интерпретаторе.

При операциях с очередью deque.popleft() значительно превосходит list.pop(0). Удаление из начала списка требует сдвига всех элементов — O(n), в то время как deque обеспечивает O(1) благодаря внутренней структуре на основе двусвязного списка или кольцевого буфера.

Реализованные алгоритмы работают корректно: проверка скобок различает корректные и некорректные последовательности, симуляция печати моделирует динамическую очередь, а проверка палиндромов верно определяет симметричные строки.

## Ответы на контрольные вопросы

1. Вставка в начало массива — O(n) (сдвиг элементов), в связный список — O(1) (смена указателя). Доступ по индексу: массив — O(1), связный список — O(n) (требуется обход).

2. Стек — LIFO: последний добавленный элемент извлекается первым (например, отмена действий). Очередь — FIFO: первый добавленный — первый извлечённый (например, очередь печати).

3. list.pop(0) — O(n), так как все элементы сдвигаются. deque.popleft() — O(1), поскольку реализован на структуре, не требующей перемещения данных.

4. Для системы отмены подходит стек: действия добавляются в него, а при отмене извлекаются в обратном порядке — строго по принципу LIFO.

5. Замеры подтверждают теорию: время вставки в начало массива растёт линейно с ростом размера, а у связного списка — остаётся практически постоянным, что соответствует O(n) и O(1) соответственно.