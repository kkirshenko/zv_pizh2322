# Лабораторная работа № 7
# Кучи (Heaps)

**Дата:** 14.12.2025
**Семестр:** 3 курс 5 семестр
**Группа:** ПИЖ-б-о-23-2-2
**Дисциплина:** Анализ сложности алгоритмов
**Студент:** Зволибовская Екатерина Валерьевна

## Характеристики ПК для тестирования
- Процессор: 11th Gen Intel(R) Core(TM) i5-11400F CPU @ 2.60 GHz
- GPU: NVIDEA GeForce RTX 4060
- Оперативная память: 16 GB
- ОС: Windows 10
- Python: 3.11 (64-bit)


## Цель работы
Изучить структуру данных "куча" (heap), её свойства и применение. Освоить основные
операции с кучей (добавление, извлечение корня) и алгоритм её построения. Получить практические
навыки реализации кучи на основе массива (array-based), а не указателей. Исследовать эффективность
основных операций и применение кучи для сортировки и реализации приоритетной очереди.

## Практическая часть

### Выполненные задачи

- [x] Реализовать структуру данных «куча» (min-heap и max-heap) на основе массива.
- [x] Реализовать основные операции кучи и алгоритм построения heapify.
- [x] Реализовать алгоритм пирамидальной сортировки (Heapsort).
- [x] Провести анализ вычислительной сложности операций.
- [x] Сравнить производительность Heapsort с другими алгоритмами сортировки.


## Результаты выполнения

### Пример работы программы

```bash
=== ДЕМОНСТРАЦИЯ ОСНОВНЫХ ОПЕРАЦИЙ С SmallHeap ===

Исходный набор: [10, 4, 1, 8, 2, 9, 5, 7, 3]

Последовательная вставка:
После push 10: SmallHeap([10])
После push 4: SmallHeap([4, 10])
После push 1: SmallHeap([1, 10, 4])
После push 8: SmallHeap([1, 8, 4, 10])
После push 2: SmallHeap([1, 2, 4, 10, 8])
После push 9: SmallHeap([1, 2, 4, 10, 8, 9])
После push 5: SmallHeap([1, 2, 4, 10, 8, 9, 5])
После push 7: SmallHeap([1, 2, 4, 7, 8, 9, 5, 10])
После push 3: SmallHeap([1, 2, 4, 3, 8, 9, 5, 10, 7])

Корень (минимум): 1
Куча валидна: True
...
```


### Сравнение алгоритмов сортировки

| Размер | Heapsort (мс) | Quicksort (мс) | Mergesort (мс) | Built-in (мс) |
| ------ | ------------- | -------------- | -------------- | ------------- |
| 100    | 0.31          | 0.23           | 0.30           | 0.02          |
| 500    | 1.83          | 1.48           | 1.57           | 0.09          |
| 1000   | 4.26          | 3.03           | 3.38           | 0.21          |
| 5000   | 29.92         | 16.53          | 21.29          | 1.28          |
| 10000  | 66.06         | 33.54          | 46.33          | 2.78          |


### Графики производительности

![Время операций над кучей](report/measure_analysis.png)

![Сравнение алгоритмов сортировки](report/compare_analysis.png)

## Инструкция по запуску

Перейти в папку **src**:

```bash
cd src
```

Запуск основной программы:

```bash
python3 main.py
```

Запуск тестов:

```bash
python3 -m modules.tests
```

Запуск анализа времени:

```bash
python3 -m modules.analysis
```


## Выводы

Структура данных «куча» обеспечивает эффективные операции вставки и удаления корневого элемента за счёт соблюдения свойства упорядоченности. Построение кучи с помощью метода heapify выполняется за линейное время O(n), что делает её удобной основой для алгоритмов сортировки. На этой базе строится Heapsort — алгоритм с гарантированной сложностью O(n log n), не требующий дополнительной памяти, однако на практике уступающий по скорости QuickSort и встроенным сортировкам Python.


## Ответы на контрольные вопросы

1. В min-куче значение любого узла не превышает значений его потомков, а в max-куче — наоборот, не меньше их.
2. При вставке элемент добавляется в конец массива, после чего выполняется операция sift_up: он последовательно сравнивается с родителем и поднимается вверх, пока не будет восстановлено свойство кучи.
3. Построение кучи из произвольного массива (через heapify) работает за O(n), поскольку операция sift_down применяется только к внутренним узлам, и большинство из них находятся на нижних уровнях дерева, где высота поддеревьев мала — суммарное количество операций оказывается линейным.
4. Heapsort сначала преобразует исходный массив в max-кучу, затем многократно извлекает максимальный элемент (корень), помещая его в конец массива, и восстанавливает кучу на оставшейся части. В результате массив сортируется на месте.
5. Куча — эффективная реализация приоритетной очереди, так как позволяет за O(log n) выполнять вставку, извлечение и удаление элемента с наивысшим приоритетом, в отличие от O(n) при поиске максимума в неупорядоченном массиве.