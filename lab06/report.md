# Лабораторная работа № 6
# Деревья. Бинарные деревья поиска

**Дата:** 13.12.2025
**Семестр:** 3 курс 5 семестр
**Группа:** ПИЖ-б-о-23-2-2
**Дисциплина:** Анализ сложности алгоритмов
**Студент:** Зволибовская Екатерина Валерьевна

## Характеристики ПК для тестирования
- Процессор: 11th Gen Intel(R) Core(TM) i5-11400F CPU @ 2.60 GHz
- GPU: NVIDEA GeForce RTX 4060
- Оперативная память: 16 GB
- ОС: Windows 10
- Python: 3.11 (64-bit)


## Цель работы
Изучить древовидные структуры данных, их свойства и применение. Освоить основные
операции с бинарными деревьями поиска (BST). Получить практические навыки реализации BST на
основе узлов (pointer-based), рекурсивных алгоритмов обхода и анализа их эффективности.
Исследовать влияние сбалансированности дерева на производительность операций.

## Практическая часть

### Выполненные задачи

- [x] Реализовать бинарное дерево поиска (BST) на основе узлов с основными операциями: вставка, поиск, удаление, вычисление свойств.
- [x] Реализовать рекурсивные и итеративные методы обхода дерева: in-order, pre-order, post-order, level-order.
- [x] Реализовать дополнительные методы анализа дерева: высота, размер, проверка корректности BST.
- [x] Провести анализ сложности операций для сбалансированного и вырожденного деревьев.
- [x] Визуализировать структуру дерева и построить график производительности.


## Результаты выполнения

### Пример работы программы

```bash
=== ДЕМОНСТРАЦИЯ BST ===

Вставляем значения: [55, 28, 72, 18, 33, 63, 88, 12, 24, 37, 47]
Размер дерева: 11
Высота дерева: 4
Минимальное значение: 12
Максимальное значение: 88
Является корректным BST: True

Рекурсивный in-order обход: [12, 18, 24, 28, 33, 37, 47, 55, 63, 72, 88]
Итеративный in-order обход: [12, 18, 24, 28, 33, 37, 47, 55, 63, 72, 88]
Pre-order обход: [55, 28, 18, 12, 24, 33, 37, 47, 72, 63, 88]
Post-order обход: [12, 24, 18, 47, 37, 33, 28, 63, 88, 72, 55]
Level-order обход: [55, 28, 72, 18, 33, 63, 88, 12, 24, 37, 47]
Значение 37 найдено
Значение 58 не найдено
Значение 18 найдено

Удаляем значение 18
Значение удалено
In-order после удаления: [12, 24, 28, 33, 37, 47, 55, 63, 72, 88]
BST корректно: True
Размер дерева после удаления: 10

Удаляем значение 28
Значение удалено
In-order после удаления: [12, 24, 33, 37, 47, 55, 63, 72, 88]
BST корректно: True
Размер дерева после удаления: 9

Удаляем значение 55
Значение удалено
In-order после удаления: [12, 24, 33, 37, 47, 63, 72, 88]
BST корректно: True
Размер дерева после удаления: 8

```

### График производительности

![BST Performance](report/bst_performance_analysis.png)


## Инструкция по запуску

Перейти в директорию `src`:

```bash
cd src
```
Запустить программу

```bash
python3 main.py
```

Запустить тесты

```bash
python3 -m modules.tests
```

Запустить анализ времени работы BST

```bash
python3 -m modules.analysis
```

## Выводы

1. Реализовано корректное бинарное дерево поиска (BST), поддерживающее все базовые операции.
2. Выполнен сравнительный анализ производительности BST в сбалансированном и вырожденном состоянии.
3. Эксперименты подтвердили теоретическую оценку: в вырожденном случае BST деградирует до линейной сложности O(n).


## Ответы на контрольные вопросы

1. В бинарном дереве поиска (BST) для любого узла выполняется: все значения в левом поддереве строго меньше значения узла, а все значения в правом поддереве — строго больше. Это свойство обеспечивает упорядоченность данных и позволяет эффективно выполнять поиск, вставку и удаление.

2. Вставка начинается с корня: значение сравнивается с текущим узлом и рекурсивно спускается влево (если меньше) или вправо (если больше), пока не найдётся пустое место для нового узла. В сбалансированном дереве сложность — O(log n), в вырожденном (в виде списка) — O(n).

3. DFS (поиск в глубину) обходит дерево, максимально углубляясь по одной ветке перед возвратом. BFS (поиск в ширину) обходит узлы по уровням — от корня к листьям, слева направо. Виды DFS:

4. При вырождении BST превращается в линейную структуру (аналог связанного списка), и для поиска или вставки элемента приходится пройти все узлы от корня до конца, что даёт линейную сложность O(n).

5. Сбалансированное дерево — это BST, в котором высота левого и правого поддеревьев любого узла отличается не более чем на фиксированную константу (обычно 1). Такие структуры, как AVL- или красно-чёрные деревья, автоматически поддерживают баланс с помощью поворотов после вставок и удалений. Это гарантирует высоту O(log n) и, соответственно, логарифмическую сложность всех основных операций, предотвращая вырождение.

