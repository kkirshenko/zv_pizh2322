# Лабораторная работа №9
## Динамическое программирование

**Дата:** 21.12.2025
**Семестр:** 3 курс 5 семестр
**Группа:** ПИЖ-б-о-23-2-2
**Дисциплина:** Анализ сложности алгоритмов
**Студент:** Зволибовская Екатерина Валерьевна

## Характеристики ПК для тестирования
- Процессор: 11th Gen Intel(R) Core(TM) i5-11400F CPU @ 2.60 GHz
- GPU: NVIDEA GeForce RTX 4060
- Оперативная память: 16 GB
- ОС: Windows 10
- Python: 3.11 (64-bit)

## Цель работы

Изучить метод динамического программирования (ДП) как мощный инструмент для решения сложных задач путём их разбиения на перекрывающиеся подзадачи. Освоить два основных подхода к реализации ДП: нисходящий (с мемоизацией) и восходящий (с заполнением таблицы). Получить практические навыки выявления оптимальной подструктуры задач, построения таблиц ДП и анализа временной и пространственной сложности алгоритмов.

## Практическая часть

### Выполненные задачи

- [x] Реализовать классические алгоритмы динамического программирования (Фибоначчи, LCS, Levenshtein, LIS, размен монет, Knapsack 0-1)
- [x] Реализовать оба подхода (нисходящий с мемоизацией и восходящий с заполнением таблиц)
- [x] Провести сравнительный анализ эффективности методов (время и память)
- [x] Проанализировать асимптотики алгоритмов и оптимизации (O(n²), O(n log n), оптимизация памяти)
- [x] Решить практические задачи с применением ДП и построить DP-таблицы


## Результаты выполнения

### Пример работы программы

```bash
======================================================================
ДИНАМИЧЕСКОЕ ПРОГРАММИРОВАНИЕ — ДЕМОНСТРАЦИИ
======================================================================

======================================================================
ПРИМЕР 1: РЯД ФИБОНАЧЧИ
======================================================================

Вычисляем F(10):
1) Наивная рекурсия: F(10) = 55
2) С кешем:        F(10) = 55
3) Восходящий:     F(10) = 55
4) Память-оптим.:  F(10) = 55

Первые 15 чисел ряда (пример):
[0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377]

======================================================================
ПРИМЕР 2: KNAPSACK 0-1
======================================================================

Входные данные:
Предметы: [(0, 2, 3), (1, 3, 4), (2, 4, 5), (3, 5, 6)]
Вместимость: 8

Максимальная стоимость: 10

С восстановлением решения:
Макс. стоимость: 10
Выбранные предметы (индексы): [1, 3]
Детали:
  Предмет 1: вес=3, стоимость=4
  Предмет 3: вес=5, стоимость=6
Итого: вес=8, стоимость=10

----------------------------------------------------------------------

Пример 2:
Предметы: [(0, 6, 30), (1, 3, 14), (2, 4, 16), (3, 2, 9)]
Вместимость: 10
Максимальная стоимость: 46
Выбранные предметы: [0, 2]

======================================================================
...
```


## Графики

### Сравнение подходов на примере Фибоначчи

![Fibonacci Comparison](./report/fibonacci_comparison.png)

### Масштабируемость Knapsack 0-1

![Knapsack Scalability](./report/knapsack_scalability.png)


## Тестирование

```bash
test_combinations ... ok
test_impossible ... ok
test_single_coin ... ok
test_with_recovery ... ok
test_zero_amount ... ok
test_base_cases ... ok
test_consistency ... ok
test_known_values ... ok
...
```

## Инструкция по запуску

```bash
cd src
python3 main.py             # запуск основной программы
python3 -m modules.tests    # запуск тестов
python3 -m modules.analysis # запуск анализа производительности
```

## Выводы

Динамическое программирование эффективно ускоряет вычисления в задачах, обладающих свойствами оптимальной подструктуры и перекрывающихся подзадач. Восходящая реализация, как правило, работает быстрее рекурсивной (нисходящей), особенно на больших объёмах данных, поскольку избегает накладных расходов на вызовы функций и обеспечивает более предсказуемый порядок вычислений. Часто удаётся значительно сократить объём используемой памяти за счёт хранения только необходимых промежуточных значений, сохраняя при этом точность результата.

## Ответы на контрольные вопросы

1. Динамическое программирование применимо к задачам, обладающим двумя ключевыми свойствами: оптимальной подструктурой (оптимальное решение содержит оптимальные решения подзадач) и перекрывающимися подзадачами (одни и те же подзадачи решаются многократно).
2. Нисходящий подход (с мемоизацией) решает только те подзадачи, которые действительно нужны, используя рекурсию и кэширование результатов. Восходящий подход решает все подзадачи итеративно, заполняя таблицу от простых случаев к сложным.
3. В задаче о рюкзаке оптимальное решение для заданной вместимости и набора предметов строится на основе оптимальных решений для меньших вместимостей и подмножеств предметов — это и есть проявление оптимальной подструктуры.
4. Таблица для задачи наибольшей общей подпоследовательности (LCS) представляет собой матрицу размером. Каждая ячейка заполняется на основе сравнения символов строк и максимального значения из соседних клеток, а сама LCS восстанавливается путём обратного обхода таблицы от нижнего правого угла.
5. Использование мемоизации или табличного метода устраняет экспоненциальное дублирование вычислений, снижая временную сложность до полиномиальной. 